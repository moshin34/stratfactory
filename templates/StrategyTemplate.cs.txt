// STRATEGY TEMPLATE (v1.3) — PER-ACCOUNT ONLY HWM (immutable), Cutoff/AutoFlat, Failsafes
// CREATED: 2025-08-13
// TARGET: NinjaTrader 8 (.NET 4.8, C# 7.3). One public class per file.
// NAMESPACE: Standalone.Strategies ; CLASS NAME must equal FILE NAME.
//
// ********* CRITICAL, IMMUTABLE RULE *********
// High-Water Mark (HWM) & BREACH markers are keyed **PER-ACCOUNT ONLY**.
// DO NOT include instrument or strategy name in the persistence key.
// This is a hard requirement and part of the IMMUTABLE plumbing.
// ********************************************
//
// Replace <StrategyName> before use. Only edit inside the ENTRY region.

#region Using declarations
using System;
using System.ComponentModel.DataAnnotations;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.Strategies;
#endregion

namespace Standalone.Strategies
{
    public class <StrategyName> : Strategy
    {
        #region Required Risk Toggles
        [NinjaScriptProperty, Display(Name="UseRiskManager", GroupName="Risk", Order=1)]
        public bool UseRiskManager { get; set; } = true;

        [NinjaScriptProperty, Display(Name="MaxDailyLoss ($)", GroupName="Risk", Order=2)]
        public double MaxDailyLoss { get; set; } = 700;

        [NinjaScriptProperty, Display(Name="CircuitBreakerDrawdown ($)", GroupName="Risk", Order=3)]
        public double CircuitBreakerDrawdown { get; set; } = 2000;

        [NinjaScriptProperty, Display(Name="PropTrailingDD ($)", GroupName="Risk", Order=4, Description="Trailing drawdown vs persistent equity high-water mark")]
        public double PropTrailingDD { get; set; } = 2500;

        [NinjaScriptProperty, Display(Name="Lockout (min)", GroupName="Risk", Order=5)]
        public int LockoutMinutes { get; set; } = 120;
        #endregion

//== BEGIN IMMUTABLE: DIAGNOSTICS ==
#region Diagnostics
private string _stratName;
private string _symbol;
private string _accountName;
private string _tf;
private string _runId;
private System.IO.StreamWriter _telemetry;
private long _telemetryBytes;

[NinjaScriptProperty]
[Display(Name="VerboseLogging", GroupName="Diagnostics", Order=900)]
public bool VerboseLogging { get; set; } = true;

[NinjaScriptProperty]
[Display(Name="WhyNoTrade", GroupName="Diagnostics", Order=901)]
public bool WhyNoTrade { get; set; } = true;

[NinjaScriptProperty]
[Display(Name="EnableJsonTelemetry", GroupName="Diagnostics", Order=902)]
public bool EnableJsonTelemetry { get; set; } = false;

[NinjaScriptProperty]
[Display(Name="TelemetryFilePath", GroupName="Diagnostics", Order=903)]
public string TelemetryFilePath { get; set; } =
    Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)
    + System.IO.Path.DirectorySeparatorChar + "NinjaTrader 8"
    + System.IO.Path.DirectorySeparatorChar + "log"
    + System.IO.Path.DirectorySeparatorChar + "StrategyLogs";

[NinjaScriptProperty]
[Display(Name="TelemetryMaxKB", GroupName="Diagnostics", Order=904)]
[Range(64, 10240)]
public int TelemetryMaxKB { get; set; } = 1024;

[NinjaScriptProperty]
[Display(Name="StrategyTag", GroupName="Diagnostics", Order=905)]
public string StrategyTag { get; set; } = "";

[NinjaScriptProperty]
[Display(Name="ExternalRefUrl", GroupName="Diagnostics", Order=906)]
public string ExternalRefUrl { get; set; } = "";

private void Dx_Init()
{
    _runId = DateTime.UtcNow.ToString("yyyyMMddTHHmmssZ");
    _stratName = Name;
    _symbol = Instrument != null ? Instrument.FullName : "<unknown>";
    try { _accountName = Account != null ? Account.Name : "<none>"; } catch { _accountName = "<none>"; }
    _tf = BarsPeriod.BarsPeriodType + ":" + BarsPeriod.Value;

    if (EnableJsonTelemetry)
    {
        try
        {
            if (!System.IO.Directory.Exists(TelemetryFilePath))
                System.IO.Directory.CreateDirectory(TelemetryFilePath);

            var file = System.IO.Path.Combine(TelemetryFilePath, _stratName + ".jsonl");
            _telemetry = new System.IO.StreamWriter(file, append: true) { AutoFlush = true };
            _telemetryBytes = new System.IO.FileInfo(file).Exists ? new System.IO.FileInfo(file).Length : 0;
        }
        catch (Exception ex)
        {
            Print($"[CFG] [{_stratName}] telemetry=disabled error={ex.Message}");
            EnableJsonTelemetry = false;
        }
    }
    Dx_Cfg();
}

private void Dx_Close()
{
    try { _telemetry?.Dispose(); } catch { }
}

private void Dx_Log(string tag, string kv)
{
    if (tag == "FILTER" && !WhyNoTrade) return;
    if (!VerboseLogging && (tag == "CFG" || tag == "STATE" || tag == "FILTER" || tag == "ORD"))
        return;
    Print($"[{tag}] [{_stratName}] {kv}");
    Dx_Json(tag, kv);
}

private void Dx_Why(string code, string detail)
{
    if (!WhyNoTrade) return;
    Dx_Log("FILTER", $"reason={code} detail={detail}");
}

private void Dx_Cfg()
{
    var p = new System.Text.StringBuilder();
    p.Append("{\"ts\":\"").Append(Times[0][0].ToUniversalTime().ToString("o"))
     .Append("\",\"event\":\"CFG\",\"runId\":\"").Append(JsonEsc(_runId))
     .Append("\",\"strat\":\"").Append(JsonEsc(_stratName))
     .Append("\",\"symbol\":\"").Append(JsonEsc(_symbol))
     .Append("\",\"tf\":\"").Append(JsonEsc(_tf))
     .Append("\",\"account\":\"").Append(JsonEsc(_accountName))
     .Append("\",\"tag\":\"").Append(JsonEsc(StrategyTag))
     .Append("\",\"ref\":\"").Append(JsonEsc(ExternalRefUrl))
     .Append("\",\"params\":{")
     .Append("\"UseRiskManager\":").Append(UseRiskManager.ToString().ToLower()).Append(",")
     .Append("\"MaxDailyLoss\":").Append(MaxDailyLoss.ToString("F2")).Append(",")
     .Append("\"CircuitBreakerDrawdown\":").Append(CircuitBreakerDrawdown.ToString("F2")).Append(",")
     .Append("\"PropTrailingDD\":").Append(PropTrailingDD.ToString("F2")).Append(",")
     .Append("\"LockoutMinutes\":").Append(LockoutMinutes)
     .Append("}}");
    Dx_WriteLine(p.ToString());
}

private void Dx_Json(string tag, string kv)
{
    if (!EnableJsonTelemetry) return;
    var parts = kv.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);
    var sb = new System.Text.StringBuilder();
    sb.Append("{\"ts\":\"").Append(Times[0][0].ToUniversalTime().ToString("o"))
      .Append("\",\"event\":\"").Append(JsonEsc(tag))
      .Append("\",\"runId\":\"").Append(JsonEsc(_runId))
      .Append("\",\"strat\":\"").Append(JsonEsc(_stratName))
      .Append("\",\"symbol\":\"").Append(JsonEsc(_symbol))
      .Append("\",\"tf\":\"").Append(JsonEsc(_tf))
      .Append("\",\"account\":\"").Append(JsonEsc(_accountName))
      .Append("\",\"ctx\":{");
    int written = 0;
    for (int i=0; i<parts.Length; i++)
    {
        var p = parts[i];
        var eq = p.IndexOf('=');
        if (eq <= 0) continue;
        var k = p.Substring(0, eq);
        var v = p.Substring(eq+1);
        if (written++>0) sb.Append(",");
        sb.Append("\"").Append(JsonEsc(k)).Append("\":\"").Append(JsonEsc(v)).Append("\"");
    }
    sb.Append("}}");
    Dx_WriteLine(sb.ToString());
}

private void Dx_WriteLine(string line)
{
    try
    {
        if (_telemetry == null) return;
        _telemetry.WriteLine(line);
        _telemetryBytes += line.Length + 1;
        var maxBytes = (long)TelemetryMaxKB * 1024L;
        if (_telemetryBytes > maxBytes)
        {
            _telemetry.Dispose();
            var path = System.IO.Path.Combine(TelemetryFilePath, _stratName + ".jsonl");
            var rotated = System.IO.Path.Combine(TelemetryFilePath, _stratName + "." + DateTime.Now.ToString("yyyyMMdd_HHmmss") + ".jsonl");
            System.IO.File.Move(path, rotated);
            _telemetry = new System.IO.StreamWriter(path, append: true) { AutoFlush = true };
            _telemetryBytes = 0;
            Print($"[CFG] [{_stratName}] telemetry=rotated file={rotated}");
        }
    }
    catch (Exception ex)
    {
        Print($"[CFG] [{_stratName}] telemetry=error msg={ex.Message}");
        EnableJsonTelemetry = false;
    }
}

private static string JsonEsc(string s)
{
    if (string.IsNullOrEmpty(s)) return "";
    return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n","\\n").Replace("\r","\\r");
}
#endregion
//== END IMMUTABLE: DIAGNOSTICS ==

//== BEGIN IMMUTABLE: RTM ==
#region Risk Profiles, Sizing, Exits (UI)
public enum RiskProfile { ECP, PCP, DCP, HR }
public enum PositionSizingMode { FixedContracts, PercentEquityRisk, MaxLossPerTrade }
public enum EntryRiskMode { StopTicks, ATRx }
public enum TrailType { Ticks, ATRx }

[NinjaScriptProperty, Display(Name="EnableLongs", GroupName="Entry", Order=5)]
public bool EnableLongs { get; set; } = true;

[NinjaScriptProperty, Display(Name="EnableShorts", GroupName="Entry", Order=6)]
public bool EnableShorts { get; set; } = true;

[NinjaScriptProperty, Display(Name="Session Window", GroupName="Filters", Order=10, Description="Format HH:mm–HH:mm, local time")]
public string SessionWindow { get; set; } = "";

// Cutoff / auto-flat
[NinjaScriptProperty, Display(Name="SessionCutoffTime (HH:mm)", GroupName="Filters", Order=15)]
public string SessionCutoffTime { get; set; } = "";

[NinjaScriptProperty, Display(Name="AutoFlatAtClose", GroupName="Filters", Order=16)]
public bool AutoFlatAtClose { get; set; } = true;

[NinjaScriptProperty, Display(Name="Cooldown Bars", GroupName="Filters", Order=17)]
[Range(0, 500)]
public int CooldownBars { get; set; } = 0;

[NinjaScriptProperty, Display(Name="Max Trades / Day", GroupName="Filters", Order=18)]
[Range(0, 100)]
public int MaxTradesPerDay { get; set; } = 99;

[NinjaScriptProperty, Display(Name="Consec Loss Lockout", GroupName="Filters", Order=19)]
[Range(0, 20)]
public int ConsecLossLockout { get; set; } = 0;

[NinjaScriptProperty, Display(Name="Pause After Win", GroupName="Filters", Order=20)]
public bool PauseAfterWin { get; set; } = false;

// Risk core
[NinjaScriptProperty, Display(Name="RiskProfile", GroupName="Risk", Order=30)]
public RiskProfile RiskProfileMode { get; set; } = RiskProfile.DCP;

[NinjaScriptProperty, Display(Name="PositionSizingMode", GroupName="Risk", Order=31)]
public PositionSizingMode SizingMode { get; set; } = PositionSizingMode.FixedContracts;

[NinjaScriptProperty, Display(Name="DefaultQuantity", GroupName="Risk", Order=32), Range(1, 100)]
public int DefaultQuantity { get; set; } = 1;

[NinjaScriptProperty, Display(Name="AccountEquityEstimate ($)", GroupName="Risk", Order=33), Range(0, double.MaxValue)]
public double AccountEquityEstimate { get; set; } = 50000;

[NinjaScriptProperty, Display(Name="RiskPerTrade ($ or %)", GroupName="Risk", Order=34), Range(0, 100000)]
public double RiskPerTrade { get; set; } = 250;

[NinjaScriptProperty, Display(Name="EntryRiskMode", GroupName="Risk", Order=35)]
public EntryRiskMode EntryRisk { get; set; } = EntryRiskMode.StopTicks;

[NinjaScriptProperty, Display(Name="Stop (ticks)", GroupName="Risk", Order=36), Range(1, 500)]
public int StopTicks { get; set; } = 40;

[NinjaScriptProperty, Display(Name="ATR Period", GroupName="Risk", Order=37), Range(5, 200)]
public int ATRPeriod { get; set; } = 14;

[NinjaScriptProperty, Display(Name="ATR Mult (x)", GroupName="Risk", Order=38), Range(0.1, 20)]
public double ATRMult { get; set; } = 1.0;

// Persistent High-Water Mark (Prop trailing DD) — PER-ACCOUNT ONLY
[NinjaScriptProperty, Display(Name="PersistHWM", GroupName="Risk", Order=39)]
public bool PersistHWM { get; set; } = true;

[NinjaScriptProperty, Display(Name="HWMFilePath", GroupName="Risk", Order=40, Description="Files are keyed PER-ACCOUNT ONLY.")]
public string HWMFilePath { get; set; } =
    Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)
    + System.IO.Path.DirectorySeparatorChar + "NinjaTrader 8"
    + System.IO.Path.DirectorySeparatorChar + "log"
    + System.IO.Path.DirectorySeparatorChar + "StrategyHWM";

// Exits
[NinjaScriptProperty, Display(Name="BE at R (x)", GroupName="Exits", Order=50), Range(0.0, 10.0)]
public double BreakEvenAtR { get; set; } = 1.0;

[NinjaScriptProperty, Display(Name="BE Plus (ticks)", GroupName="Exits", Order=51), Range(0, 50)]
public int BEPlusTicks { get; set; } = 0;

[NinjaScriptProperty, Display(Name="TP1 @ R (x)", GroupName="Exits", Order=52), Range(0.1, 20)]
public double TP1_RMultiple { get; set; } = 1.0;

[NinjaScriptProperty, Display(Name="TP1 %", GroupName="Exits", Order=53), Range(0, 100)]
public int TP1_Pct { get; set; } = 50;

[NinjaScriptProperty, Display(Name="TP2 @ R (x)", GroupName="Exits", Order=54), Range(0.1, 20)]
public double TP2_RMultiple { get; set; } = 2.0;

[NinjaScriptProperty, Display(Name="TP2 %", GroupName="Exits", Order=55), Range(0, 100)]
public int TP2_Pct { get; set; } = 25;

[NinjaScriptProperty, Display(Name="Trail Start @ R (x)", GroupName="Exits", Order=56), Range(0.0, 20)]
public double TP3_TrailingStartR { get; set; } = 2.0;

[NinjaScriptProperty, Display(Name="TP3 % (Trail)", GroupName="Exits", Order=57), Range(0, 100)]
public int TP3_Pct { get; set; } = 25;

[NinjaScriptProperty, Display(Name="Trail Type", GroupName="Exits", Order=58)]
public TrailType TrailMode { get; set; } = TrailType.Ticks;

[NinjaScriptProperty, Display(Name="Trail (ticks)", GroupName="Exits", Order=59), Range(1, 500)]
public int TrailTicks { get; set; } = 30;

[NinjaScriptProperty, Display(Name="Trail ATR Mult (x)", GroupName="Exits", Order=60), Range(0.1, 20)]
public double TrailATRMult { get; set; } = 1.0;

// Failsafes
[NinjaScriptProperty, Display(Name="FlattenOnDisconnect", GroupName="Failsafes", Order=70)]
public bool FlattenOnDisconnect { get; set; } = true;

[NinjaScriptProperty, Display(Name="ProtectOnStopReject", GroupName="Failsafes", Order=71)]
public bool ProtectOnStopReject { get; set; } = true;

// Toggle: start next session in lockout once per breach
[NinjaScriptProperty, Display(Name="StartNextSessionLockoutOnBreach", GroupName="Failsafes", Order=72)]
public bool StartNextSessionLockoutOnBreach { get; set; } = true;
#endregion

#region RTM Internals
private string _entrySignal = "ENTRY";
private string _tp1Signal = "TP1";
private string _tp2Signal = "TP2";

private double _avgEntry;
private double _initStop;
private int _rticks;
private int _tp1Qty;
private int _tp2Qty;
private int _trailQty;
private bool _beMoved;
private bool _trailArmed;

private int _tradesToday;
private int _losingStreak;
private DateTime _lastTradeTime = DateTime.MinValue;

// Persistent High-Water Mark (never daily reset)
private double _hwmEquity = 0;
// Lockout timer and optional session cutoff
private DateTime _lockoutUntil = DateTime.MinValue;
private TimeSpan? _cutoffTs = null;
// Prior-breach flag (for next-session lockout)
private bool _breachFlag = false;

private NinjaTrader.NinjaScript.Indicators.ATR _atr;
#endregion

#region RTM Helpers (PER-ACCOUNT file stem)
private static string Sanitize(string s)
{
    if (string.IsNullOrEmpty(s)) return "NA";
    foreach (var c in System.IO.Path.GetInvalidFileNameChars())
        s = s.Replace(c, '_');
    return s;
}

private string RTM_FileStem()
{
    // ***** PER-ACCOUNT ONLY ***** — DO NOT change to include instrument or strategy
    string acct = "<BACKTEST>";
    try { if (Account != null && !string.IsNullOrEmpty(Account.Name)) acct = Account.Name; } catch { }
    return Sanitize(acct);
}
#endregion

#region RTM Life-cycle Hooks
private void RTM_OnStateChange()
{
    if (State == State.SetDefaults)
    {
        // defaults declared in properties
    }
    else if (State == State.Configure)
    {
        if (_atr == null) _atr = ATR(ATRPeriod);
    }
    else if (State == State.DataLoaded)
    {
        // Normalize TP percentages
        int sum = TP1_Pct + TP2_Pct + TP3_Pct;
        if (sum <= 0) { TP1_Pct = 50; TP2_Pct = 25; TP3_Pct = 25; sum = 100; }
        if (sum != 100)
        {
            double f = 100.0 / sum;
            TP1_Pct = Math.Max(0, (int)Math.Round(TP1_Pct * f));
            TP2_Pct = Math.Max(0, (int)Math.Round(TP2_Pct * f));
            TP3_Pct = 100 - TP1_Pct - TP2_Pct;
            Print($"[CFG] [{Name}] normalized TP pct: {TP1_Pct}/{TP2_Pct}/{TP3_Pct}");
        }

        // HWM init & optional load (PER-ACCOUNT ONLY)
        try
        {
            var eq = Account != null ? Account.Get(AccountItem.NetLiquidation, Currency.UsDollar) : AccountEquityEstimate;
            if (eq > 0 && _hwmEquity <= 0) _hwmEquity = eq;

            if (PersistHWM)
            {
                if (!System.IO.Directory.Exists(HWMFilePath))
                    System.IO.Directory.CreateDirectory(HWMFilePath);

                var stem = RTM_FileStem();
                var fn = System.IO.Path.Combine(HWMFilePath, stem + "_HWM.txt");
                if (System.IO.File.Exists(fn))
                {
                    var text = System.IO.File.ReadAllText(fn).Trim();
                    double saved;
                    if (double.TryParse(text, out saved) && saved > 0)
                        _hwmEquity = Math.Max(_hwmEquity, saved);
                }

                var bf = System.IO.Path.Combine(HWMFilePath, stem + "_BREACH.txt");
                if (StartNextSessionLockoutOnBreach && System.IO.File.Exists(bf))
                {
                    _breachFlag = true;
                }
            }

            // Parse cutoff once
            if (!string.IsNullOrWhiteSpace(SessionCutoffTime))
            {
                TimeSpan ts;
                _cutoffTs = TimeSpan.TryParse(SessionCutoffTime, out ts) ? ts : (TimeSpan?)null;
            }
        }
        catch { /* ignore */ }
    }
}
#endregion

#region RTM Entry Arming API
private int RTM_ComputeQty(double entryPrice, double stopPrice)
{
    int q = DefaultQuantity;
    try
    {
        double equity = Account != null
            ? Account.Get(AccountItem.NetLiquidation, Currency.UsDollar)
            : AccountEquityEstimate;
        if (equity <= 0) equity = AccountEquityEstimate;

        double riskPerContract = Math.Abs(entryPrice - stopPrice) / TickSize * Instrument.MasterInstrument.PointValue * TickSize;
        if (riskPerContract <= 0) return Math.Max(1, DefaultQuantity);

        if (SizingMode == PositionSizingMode.FixedContracts)
            q = DefaultQuantity;
        else if (SizingMode == PositionSizingMode.PercentEquityRisk)
            q = (int)Math.Floor((equity * (RiskPerTrade / 100.0)) / riskPerContract);
        else if (SizingMode == PositionSizingMode.MaxLossPerTrade)
            q = (int)Math.Floor(RiskPerTrade / riskPerContract);

        q = Math.Max(1, q);
    }
    catch { q = Math.Max(1, DefaultQuantity); }
    return q;
}

public void RTM_ArmEntryLong(double plannedEntryPrice)
{
    double stop = (EntryRisk == EntryRiskMode.ATRx)
        ? plannedEntryPrice - (_atr[0] * ATRMult)
        : plannedEntryPrice - (StopTicks * TickSize);
    RTM_Prime(plannedEntryPrice, stop, true);
}

public void RTM_ArmEntryShort(double plannedEntryPrice)
{
    double stop = (EntryRisk == EntryRiskMode.ATRx)
        ? plannedEntryPrice + (_atr[0] * ATRMult)
        : plannedEntryPrice + (StopTicks * TickSize);
    RTM_Prime(plannedEntryPrice, stop, false);
}

private void RTM_Prime(double entry, double stop, bool isLong)
{
    _avgEntry = entry;
    _initStop = stop;
    _rticks = (int)Math.Max(1, Math.Round(Math.Abs(entry - stop) / TickSize));

    int qty = RTM_ComputeQty(entry, stop);
    _tp1Qty = (int)Math.Max(0, Math.Round(qty * (TP1_Pct / 100.0)));
    _tp2Qty = (int)Math.Max(0, Math.Round(qty * (TP2_Pct / 100.0)));
    _trailQty = Math.Max(0, qty - _tp1Qty - _tp2Qty);
    if (_tp1Qty + _tp2Qty + _trailQty != qty) _trailQty = Math.Max(0, qty - _tp1Qty - _tp2Qty);

    _beMoved = false;
    _trailArmed = false;

    Print($"[ENTRY] [{Name}] side={(isLong ? "Long":"Short")} price={entry:F2} qty={qty} RTicks={_rticks}");

    if (isLong) EnterLong(qty, _entrySignal);
    else EnterShort(qty, _entrySignal);
}
#endregion

#region RTM Runtime Management
private void RTM_OnBarUpdate()
{
    if (CurrentBar < 5) return;

    // Session cutoff enforcement (disallow new entries and optional auto-flat)
    if (_cutoffTs.HasValue)
    {
        var nowLocal = Time[0];
        var cutoffToday = nowLocal.Date + _cutoffTs.Value;
        if (nowLocal >= cutoffToday)
        {
            if (AutoFlatAtClose && Position.MarketPosition != MarketPosition.Flat)
            {
                if (Position.MarketPosition == MarketPosition.Long) ExitLong();
                else if (Position.MarketPosition == MarketPosition.Short) ExitShort();
                Dx_Log("RISK", $"auto_flat=1 reason=SessionCutoff time={nowLocal:HH:mm}");
            }
            // Disable entries; ENTRY block should respect EnableEntries
            EnableEntries = false;
        }
    }

    // Move to break-even
    if (!_beMoved && Position.MarketPosition != MarketPosition.Flat && _rticks > 0)
    {
        double rNowTicks = Position.MarketPosition == MarketPosition.Long
            ? (Close[0] - _avgEntry) / TickSize
            : (_avgEntry - Close[0]) / TickSize;

        if (rNowTicks >= BreakEvenAtR * _rticks)
        {
            double bePrice = _avgEntry + (Position.MarketPosition == MarketPosition.Long ? BEPlusTicks * TickSize : -BEPlusTicks * TickSize);
            RTM_UpdateStop(bePrice);
            _beMoved = true;
            Print($"[EXIT] [{Name}] reason=BEMove stop={bePrice:F2} rNowTicks={rNowTicks:F1}");
        }
    }

    // Trailing logic arming & updates
    if (Position.MarketPosition != MarketPosition.Flat && !_trailArmed && _rticks > 0)
    {
        double rNowTicks = Position.MarketPosition == MarketPosition.Long
            ? (Close[0] - _avgEntry) / TickSize
            : (_avgEntry - Close[0]) / TickSize;
        if (rNowTicks >= TP3_TrailingStartR * _rticks)
            _trailArmed = true;
    }

    if (Position.MarketPosition != MarketPosition.Flat && _trailArmed)
    {
        double newStop;
        if (TrailMode == TrailType.Ticks)
        {
            newStop = Position.MarketPosition == MarketPosition.Long
                ? Close[0] - TrailTicks * TickSize
                : Close[0] + TrailTicks * TickSize;
        }
        else
        {
            double offs = _atr[0] * TrailATRMult;
            newStop = Position.MarketPosition == MarketPosition.Long ? Close[0] - offs : Close[0] + offs;
        }

        if (Position.MarketPosition == MarketPosition.Long)
        {
            if (newStop > _initStop) { _initStop = newStop; RTM_UpdateStop(_initStop); Print($"[EXIT] [{Name}] reason=TrailUpdate stop={_initStop:F2}"); }
        }
        else
        {
            if (newStop < _initStop) { _initStop = newStop; RTM_UpdateStop(_initStop); Print($"[EXIT] [{Name}] reason=TrailUpdate stop={_initStop:F2}"); }
        }
    }
}

private void RTM_OnOrderUpdate(Order order) { /* reserved for future */ }

private void RTM_OnExecutionUpdate(Execution execution, Order order)
{
    if (execution == null || order == null) return;

    if (order.FromEntrySignal == _entrySignal && order.OrderState == OrderState.Filled)
    {
        _avgEntry = execution.Price;
        RTM_UpdateStop(_initStop);

        double tp1Price, tp2Price;
        if (Position.MarketPosition == MarketPosition.Long)
        {
            tp1Price = _avgEntry + TP1_RMultiple * _rticks * TickSize;
            tp2Price = _avgEntry + TP2_RMultiple * _rticks * TickSize;
        }
        else
        {
            tp1Price = _avgEntry - TP1_RMultiple * _rticks * TickSize;
            tp2Price = _avgEntry - TP2_RMultiple * _rticks * TickSize;
        }

        if (_tp1Qty > 0) ExitFromPositionLimit(_tp1Qty, tp1Price, _tp1Signal);
        if (_tp2Qty > 0) ExitFromPositionLimit(_tp2Qty, tp2Price, _tp2Signal);
    }
}
#endregion

#region RTM Helpers
private void RTM_UpdateStop(double price)
{
    SetStopLoss(_entrySignal, CalculationMode.Price, price, false);
}

private void ExitFromPositionLimit(int qty, double price, string signalName)
{
    if (Position.MarketPosition == MarketPosition.Long)
        ExitLongLimit(qty, price, signalName, _entrySignal);
    else if (Position.MarketPosition == MarketPosition.Short)
        ExitShortLimit(qty, price, signalName, _entrySignal);
}

private void RTM_SaveHWMIfNeeded(double equity)
{
    if (equity <= 0) return;
    if (equity > _hwmEquity)
    {
        _hwmEquity = equity;
        if (PersistHWM)
        {
            try
            {
                if (!System.IO.Directory.Exists(HWMFilePath))
                    System.IO.Directory.CreateDirectory(HWMFilePath);
                var stem = RTM_FileStem();
                var fn = System.IO.Path.Combine(HWMFilePath, stem + "_HWM.txt");
                System.IO.File.WriteAllText(fn, _hwmEquity.ToString("F2"));
            } catch { }
        }
    }
}
#endregion
//== END IMMUTABLE: RTM ==

        #region Entry Parameters
        [NinjaScriptProperty, Display(Name="EnableEntries", GroupName="Entry", Order=100)]
        public bool EnableEntries { get; set; } = true;
        #endregion

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "<StrategyName>";
                Calculate = Calculate.OnBarClose;
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;
                IsUnmanaged = false;
                IsInstantiatedOnEachOptimizationIteration = false;
            }
            else if (State == State.Configure)
            {
                RTM_OnStateChange();
                Dx_Init();
            }
            else if (State == State.Terminated)
            {
                Dx_Close();
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < 5) return;

            // Disconnect heuristic → flatten & lockout
            try
            {
                if (FlattenOnDisconnect && Account != null)
                {
                    double eqCheck = Account.Get(AccountItem.NetLiquidation, Currency.UsDollar);
                    RTM_SaveHWMIfNeeded(eqCheck);
                }
            }
            catch
            {
                if (Position.MarketPosition == MarketPosition.Long) ExitLong();
                else if (Position.MarketPosition == MarketPosition.Short) ExitShort();
                _lockoutUntil = Time[0].AddMinutes(LockoutMinutes);
                Dx_Log("RISK", $"protective_flat=1 reason=DisconnectDetected lockoutMin={LockoutMinutes}");
                return;
            }

            // Trailing DD & CircuitBreaker vs PERSISTENT HWM (PER ACCOUNT ONLY)
            if (UseRiskManager && Account != null)
            {
                var equity = Account.Get(AccountItem.NetLiquidation, Currency.UsDollar);
                RTM_SaveHWMIfNeeded(equity);

                var draw = _hwmEquity - equity; // never daily-reset
                if (draw >= PropTrailingDD || draw >= CircuitBreakerDrawdown)
                {
                    if (Position.MarketPosition == MarketPosition.Long) ExitLong();
                    else if (Position.MarketPosition == MarketPosition.Short) ExitShort();

                    _lockoutUntil = Time[0].AddMinutes(LockoutMinutes);

                    // Persist next-session lockout flag (PER ACCOUNT ONLY) if toggle is on
                    if (StartNextSessionLockoutOnBreach && PersistHWM)
                    {
                        try
                        {
                            if (!System.IO.Directory.Exists(HWMFilePath))
                                System.IO.Directory.CreateDirectory(HWMFilePath);
                            var stem = RTM_FileStem();
                            System.IO.File.WriteAllText(System.IO.Path.Combine(HWMFilePath, stem + "_BREACH.txt"), DateTime.UtcNow.ToString("o"));
                        } catch { }
                    }

                    Dx_Log("RISK", $"breach=1 type={(draw >= PropTrailingDD ? "PropDD":"CircuitBreaker")} draw={draw:F2} hwm={_hwmEquity:F2} eq={equity:F2} lockoutMin={LockoutMinutes}");
                    return;
                }
            }

            // Honor lockout window
            if (Time[0] < _lockoutUntil)
            {
                Dx_Why("LOCKOUT", $"until={_lockoutUntil:HH:mm}");
                return;
            }

            // Apply prior-breach start-of-session lockout once (and clear marker)
            if (_breachFlag && StartNextSessionLockoutOnBreach)
            {
                _breachFlag = false; // apply once
                _lockoutUntil = Time[0].AddMinutes(LockoutMinutes);
                Dx_Log("RISK", $"start_lockout=1 reason=PriorBreach lockoutMin={LockoutMinutes}");

                // remove marker so it's "once per breach"
                try
                {
                    var stem = RTM_FileStem();
                    var bf = System.IO.Path.Combine(HWMFilePath, stem + "_BREACH.txt");
                    if (System.IO.File.Exists(bf)) System.IO.File.Delete(bf);
                } catch { }
                return;
            }

            // Always run RTM (handles BE/Trail updates & cutoff)
            RTM_OnBarUpdate();

            if (!EnableEntries) { Dx_Why("ENTRIES_DISABLED", "EnableEntries=false"); return; }

//== BEGIN ENTRY LOGIC (EDITABLE) ==
// Codex: implement entry-only logic here.
// e.g. if (CrossAbove(EMA(9), EMA(21), 1) && EnableLongs) RTM_ArmEntryLong(Close[0]);
//      if (CrossBelow(EMA(9), EMA(21), 1) && EnableShorts) RTM_ArmEntryShort(Close[0]);
//== END ENTRY LOGIC (EDITABLE) ==
        }

        protected override void OnExecutionUpdate(Execution execution, Order order)
        {
            RTM_OnExecutionUpdate(execution, order);
        }

        protected override void OnOrderUpdate(Order order)
        {
            RTM_OnOrderUpdate(order);

            // Fail-safe: if a stop/target tied to the ENTRY gets rejected, flatten & lockout
            if (ProtectOnStopReject && order != null && order.OrderState == OrderState.Rejected)
            {
                if (order.FromEntrySignal == "ENTRY")
                {
                    if (Position.MarketPosition == MarketPosition.Long) ExitLong();
                    else if (Position.MarketPosition == MarketPosition.Short) ExitShort();
                    _lockoutUntil = Time[0].AddMinutes(LockoutMinutes);
                    Dx_Log("RISK", $"protective_flat=1 reason=StopOrTargetRejected order={order.Name} lockoutMin={LockoutMinutes}");
                }
            }
        }
    }
}
